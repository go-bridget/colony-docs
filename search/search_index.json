{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Colony? Colony is a simple DNS-based service discovery for stand-alone Docker hosts. It is aiming to provide a low-touch method that doesn't require modifying your applications to enable service discovery. The Colony Agent listens to the Docker events API for container start and stop events, and then registers or unregisters the DNS records on the Colony Registry based on the container name and labels. The Colony Registry provides a DNS service for resolution. By running the Agent on multiple docker hosts, cluster-wide service discovery is achieved. For stand-alone docker hosts, a local service proxy is recommended: jwilder/nginx wemake-services/caddy-gen Using a service proxy means that you can route the traffic from a consistent port (e.g. 80 ) to the individual local service containers. The individual containers don't need to expose any ports in this case.","title":"What is Colony?"},{"location":"#what-is-colony","text":"Colony is a simple DNS-based service discovery for stand-alone Docker hosts. It is aiming to provide a low-touch method that doesn't require modifying your applications to enable service discovery. The Colony Agent listens to the Docker events API for container start and stop events, and then registers or unregisters the DNS records on the Colony Registry based on the container name and labels. The Colony Registry provides a DNS service for resolution. By running the Agent on multiple docker hosts, cluster-wide service discovery is achieved. For stand-alone docker hosts, a local service proxy is recommended: jwilder/nginx wemake-services/caddy-gen Using a service proxy means that you can route the traffic from a consistent port (e.g. 80 ) to the individual local service containers. The individual containers don't need to expose any ports in this case.","title":"What is Colony?"},{"location":"topology/","text":"Topology The following diagrams illustrate the basic principles of Colony. Service registration / unregistration Colony Agents running on each Docker host are forwarding container names to registry servers. When containers get shut down, they also get unregistered from the configured registries. Resolving services As applications query the DNS server, it responds with the host IP which is running an application instance. The application connects to the host directly, while a service mesh would proxy the request. Connecting to services By using either nginx-proxy or caddy-gen or some other strategy to route requests from an ingress point on the host to the individual containers, we can connect and query individual services on the host. These proxies work in a similar way to Colony, in that any start or stop of the docker containers will update the proxy configuration, so requests can be routed to your services.","title":"Topology"},{"location":"topology/#topology","text":"The following diagrams illustrate the basic principles of Colony.","title":"Topology"},{"location":"topology/#service-registration-unregistration","text":"Colony Agents running on each Docker host are forwarding container names to registry servers. When containers get shut down, they also get unregistered from the configured registries.","title":"Service registration / unregistration"},{"location":"topology/#resolving-services","text":"As applications query the DNS server, it responds with the host IP which is running an application instance. The application connects to the host directly, while a service mesh would proxy the request.","title":"Resolving services"},{"location":"topology/#connecting-to-services","text":"By using either nginx-proxy or caddy-gen or some other strategy to route requests from an ingress point on the host to the individual containers, we can connect and query individual services on the host. These proxies work in a similar way to Colony, in that any start or stop of the docker containers will update the proxy configuration, so requests can be routed to your services.","title":"Connecting to services"},{"location":"agent/","text":"About The Colony Agent is a service that provides: Reading container lifecycle events from docker.sock or remote API, Registering and Unregistering container names on the Colony Registry API A pprof endpoint on port 6060, enabled by default In order to work, you will need to adjust permissions of the container user group to enable access to docker.sock , and Colony Registry endpoints need to be configured . The Colony Agent needs to run on every host with running services. It will broadcast container names and labels to configured registries. Upon start-up, all running containers will be sent to the registries.","title":"About"},{"location":"agent/#about","text":"The Colony Agent is a service that provides: Reading container lifecycle events from docker.sock or remote API, Registering and Unregistering container names on the Colony Registry API A pprof endpoint on port 6060, enabled by default In order to work, you will need to adjust permissions of the container user group to enable access to docker.sock , and Colony Registry endpoints need to be configured . The Colony Agent needs to run on every host with running services. It will broadcast container names and labels to configured registries. Upon start-up, all running containers will be sent to the registries.","title":"About"},{"location":"agent/config/","text":"Configuration The Colony Agent supports configuration via flags and environment variables. # ./agent-linux-amd64 --help Usage: colony-agent (command) [--flags] start Start colony agent service --pprof-addr string pprof listen address (default \":6060\") --registry host:port,... Registry HTTP RPC endpoints (CSV, host:port,...) pflag: help requested The Agent can be configured using the following environment variables: REGISTRY (e.g. host1:3000,host2:3000 ) PPROF_ADDR (default :6060 , set to 0 , false or off to disable) Adjust your docker-compose.yml according to your needs.","title":"Configuration"},{"location":"agent/config/#configuration","text":"The Colony Agent supports configuration via flags and environment variables. # ./agent-linux-amd64 --help Usage: colony-agent (command) [--flags] start Start colony agent service --pprof-addr string pprof listen address (default \":6060\") --registry host:port,... Registry HTTP RPC endpoints (CSV, host:port,...) pflag: help requested The Agent can be configured using the following environment variables: REGISTRY (e.g. host1:3000,host2:3000 ) PPROF_ADDR (default :6060 , set to 0 , false or off to disable) Adjust your docker-compose.yml according to your needs.","title":"Configuration"},{"location":"agent/permissions/","text":"Permissions By default, the Docker image built drops all privileges to nobody , uid=65534(nobody) , gid=65534(nobody) . This means, you will need to adjust the permissions by declaring DOCKER_GID used in the Docker Compose configuration. To find out the docker.sock group ID on your system: # stat -c \"%g\" /var/run/docker.sock 128 You can use this Makefile which does this for you (Linux only, For OSX it should be stat -f instead of stat -c ). .PHONY : all up down restart logs meta export DOCKER_GID = $( shell stat -c \"%g\" /var/run/docker.sock ) all : meta up up : @docker-compose up -d --remove-orphans down : @docker-compose down --remove-orphans pull : @docker-compose pull restart : @docker-compose restart logs : @docker-compose logs -f meta : @echo -n Put the Makefile in the same folder as docker-compose.yml and run make to start the agent. Other container lifecycle commands include: make up - start the containers make down - stop the containers make pull - pull the latest version make restart - restart the containers make logs - view container logs make meta - helper to generate metadata like .env files","title":"Permissions"},{"location":"agent/permissions/#permissions","text":"By default, the Docker image built drops all privileges to nobody , uid=65534(nobody) , gid=65534(nobody) . This means, you will need to adjust the permissions by declaring DOCKER_GID used in the Docker Compose configuration. To find out the docker.sock group ID on your system: # stat -c \"%g\" /var/run/docker.sock 128 You can use this Makefile which does this for you (Linux only, For OSX it should be stat -f instead of stat -c ). .PHONY : all up down restart logs meta export DOCKER_GID = $( shell stat -c \"%g\" /var/run/docker.sock ) all : meta up up : @docker-compose up -d --remove-orphans down : @docker-compose down --remove-orphans pull : @docker-compose pull restart : @docker-compose restart logs : @docker-compose logs -f meta : @echo -n Put the Makefile in the same folder as docker-compose.yml and run make to start the agent. Other container lifecycle commands include: make up - start the containers make down - stop the containers make pull - pull the latest version make restart - restart the containers make logs - view container logs make meta - helper to generate metadata like .env files","title":"Permissions"},{"location":"agent/setup/","text":"Getting started The supported way of setting up the Colony Agent is using docker-compose . Create the following docker-compose.yml file: version : '3.5' services : colony-agent : hostname : colony-agent container_name : colony-agent image : gobridget/colony-agent:latest restart : always user : \"65534:$DOCKER_GID\" volumes : # needs socket to read events - /var/run/docker.sock:/var/run/docker.sock:ro environment : - REGISTRY=172.17.0.1:30000 You will need to declare $DOCKER_GID to match your docker.sock group. Please see the permissions section to continue.","title":"Getting started"},{"location":"agent/setup/#getting-started","text":"The supported way of setting up the Colony Agent is using docker-compose . Create the following docker-compose.yml file: version : '3.5' services : colony-agent : hostname : colony-agent container_name : colony-agent image : gobridget/colony-agent:latest restart : always user : \"65534:$DOCKER_GID\" volumes : # needs socket to read events - /var/run/docker.sock:/var/run/docker.sock:ro environment : - REGISTRY=172.17.0.1:30000 You will need to declare $DOCKER_GID to match your docker.sock group. Please see the permissions section to continue.","title":"Getting started"},{"location":"deploy/","text":"HTTP API In addition to checking the log output of both the Agent and Registry, the Registry allows you to query the registered service names via a HTTP request: ENDPOINT = http://127.0.0.1:30000/twirp/registry.RegistryService/List curl -s -XPOST -d \"{}\" -H \"Content-type: application/json\" | jq '.records | keys' The List API call lists all the domains and the IPs they point to. Using jq '.records | keys' we only display the domains for brevity: [ \"colony-agent.service.\" , \"colony-docs_mkdocs_1.service.\" , \"colony-registry.service.\" , \"gotenberg.service.\" , \"mkdocs.service.\" , \"nginx-proxy.service.\" , \"offers_gotenberg_1.service.\" , \"sink.service.\" , \"sink_sink_1.service.\" ] The API is protobuf enabled, but the JSON transport is in use. The protobuf definitions are located in repository/rpc/repository.proto . The API surface is minimal, but may be extended to add functionality.","title":"HTTP API"},{"location":"deploy/#http-api","text":"In addition to checking the log output of both the Agent and Registry, the Registry allows you to query the registered service names via a HTTP request: ENDPOINT = http://127.0.0.1:30000/twirp/registry.RegistryService/List curl -s -XPOST -d \"{}\" -H \"Content-type: application/json\" | jq '.records | keys' The List API call lists all the domains and the IPs they point to. Using jq '.records | keys' we only display the domains for brevity: [ \"colony-agent.service.\" , \"colony-docs_mkdocs_1.service.\" , \"colony-registry.service.\" , \"gotenberg.service.\" , \"mkdocs.service.\" , \"nginx-proxy.service.\" , \"offers_gotenberg_1.service.\" , \"sink.service.\" , \"sink_sink_1.service.\" ] The API is protobuf enabled, but the JSON transport is in use. The protobuf definitions are located in repository/rpc/repository.proto . The API surface is minimal, but may be extended to add functionality.","title":"HTTP API"},{"location":"deploy/dns/","text":"DNS Each Colony Registry server listens on udp :5353 by default for DNS requests. Requests not in the defined service zone will result in a NXDOMAIN (Non-existent domain). Notice : The Colony Registry server doesn't perform DNS forwarding. You can use the following script to query multiple domains using dig , adjusting the hosts and destination port and hostname as deployed. #!/bin/bash NAMES = \"colony-agent colony-registry nginx-proxy\" for NAME in $NAMES ; do dig -p 53530 $NAME .service @localhost | egrep -v '^(;|$)' done The above gives the following output: colony - agent . service . 3600 IN A 172.24.0.2 colony - registry . service . 3600 IN A 172.24.0.2 nginx - proxy . service . 3600 IN A 172.24.0.2","title":"DNS"},{"location":"deploy/dns/#dns","text":"Each Colony Registry server listens on udp :5353 by default for DNS requests. Requests not in the defined service zone will result in a NXDOMAIN (Non-existent domain). Notice : The Colony Registry server doesn't perform DNS forwarding. You can use the following script to query multiple domains using dig , adjusting the hosts and destination port and hostname as deployed. #!/bin/bash NAMES = \"colony-agent colony-registry nginx-proxy\" for NAME in $NAMES ; do dig -p 53530 $NAME .service @localhost | egrep -v '^(;|$)' done The above gives the following output: colony - agent . service . 3600 IN A 172.24.0.2 colony - registry . service . 3600 IN A 172.24.0.2 nginx - proxy . service . 3600 IN A 172.24.0.2","title":"DNS"},{"location":"registry/","text":"About The Colony Registry is a service that provides: A HTTP API on port 3000 A DNS responder on UDP port 5353 A pprof endpoint on port 6060, enabled by default Any Colony Registry installation should allow traffic on these two ports. Since the Colony Registries don't communicate in a P2P/RAFT/consensus fashion, we can tolerate an outage of N-1 nodes. If a Colony Registry goes offline, it will receive the complete container lists from Agents upon it's return. We recommend having at least 2 instances. Recommended setup: Two Dedicated hosts for Colony Registry, No particular resource requirements (lowmem, lowdisk,...) It is expected that the Colony Registry is set up on stand-alone docker hosts with docker \"host\" networking, but port forwarding is functional as well. In case of host networking, the DNS service will respond with the shortest path. For example: host1: [web.service, api.service, db.service] host2: [web.service, api.service] host3: [elk-apm.service] host4: [elk-apm.service] Example queries and responses: host1: web.service => [host1]* host2: elk-apm.service => [host3, host4] host3: api.service => [host1, host2] The shortest path example are queries from host1 and host2 for the services that are running on both hosts. If the requested service lives on the same host where the query is coming from, then Colony Registry will resolve the DNS query onto the source host. If Colony Registry is running on a bridge network with exposed ports, the DNS query source IP will be the docker gateway, docker0 , and not the source IPs from the various hosts. This makes shortest path responses only possible with the host network. This is also why it's not possible to run the Colony Registry on shared hosts, as the requests will come from the various LAN IPs on the Docker networks. It's possible that this will be improved in the future, by specifying the host IP on the Colony Agents.","title":"About"},{"location":"registry/#about","text":"The Colony Registry is a service that provides: A HTTP API on port 3000 A DNS responder on UDP port 5353 A pprof endpoint on port 6060, enabled by default Any Colony Registry installation should allow traffic on these two ports. Since the Colony Registries don't communicate in a P2P/RAFT/consensus fashion, we can tolerate an outage of N-1 nodes. If a Colony Registry goes offline, it will receive the complete container lists from Agents upon it's return. We recommend having at least 2 instances. Recommended setup: Two Dedicated hosts for Colony Registry, No particular resource requirements (lowmem, lowdisk,...) It is expected that the Colony Registry is set up on stand-alone docker hosts with docker \"host\" networking, but port forwarding is functional as well. In case of host networking, the DNS service will respond with the shortest path. For example: host1: [web.service, api.service, db.service] host2: [web.service, api.service] host3: [elk-apm.service] host4: [elk-apm.service] Example queries and responses: host1: web.service => [host1]* host2: elk-apm.service => [host3, host4] host3: api.service => [host1, host2] The shortest path example are queries from host1 and host2 for the services that are running on both hosts. If the requested service lives on the same host where the query is coming from, then Colony Registry will resolve the DNS query onto the source host. If Colony Registry is running on a bridge network with exposed ports, the DNS query source IP will be the docker gateway, docker0 , and not the source IPs from the various hosts. This makes shortest path responses only possible with the host network. This is also why it's not possible to run the Colony Registry on shared hosts, as the requests will come from the various LAN IPs on the Docker networks. It's possible that this will be improved in the future, by specifying the host IP on the Colony Agents.","title":"About"},{"location":"registry/config/","text":"Configuration The Colony Registry supports configuration via flags and environment variables. # ./registry-linux-amd64 --help Usage: registry (command) [--flags] start Start colony registry service --dns-addr string DNS listen address (default \":5353\") --http-addr string HTTP API listen address (default \":3000\") --pprof-addr string pprof listen address (default \":6060\") --zone string DNS zone for service discovery (default \".service\") pflag: help requested The Registry can be configured using the following environment variables: DNS_ADDR (default :5353 ) HTTP_ADDR (default :3000 ) PPROF_ADDR (default :6060 , set to 0 , false or off to disable) ZONE (default: .service ) Adjust your docker-compose.yml according to your needs.","title":"Configuration"},{"location":"registry/config/#configuration","text":"The Colony Registry supports configuration via flags and environment variables. # ./registry-linux-amd64 --help Usage: registry (command) [--flags] start Start colony registry service --dns-addr string DNS listen address (default \":5353\") --http-addr string HTTP API listen address (default \":3000\") --pprof-addr string pprof listen address (default \":6060\") --zone string DNS zone for service discovery (default \".service\") pflag: help requested The Registry can be configured using the following environment variables: DNS_ADDR (default :5353 ) HTTP_ADDR (default :3000 ) PPROF_ADDR (default :6060 , set to 0 , false or off to disable) ZONE (default: .service ) Adjust your docker-compose.yml according to your needs.","title":"Configuration"},{"location":"registry/setup/","text":"Getting started The supported way of setting up the Colony Registry is using docker-compose . Create the following docker-compose.yml file: version : '3.5' services : colony-registry : network_mode : host hostname : colony-registry container_name : colony-registry image : gobridget/colony-registry:latest restart : always Start up the Colony Registry with docker-compose up -d .","title":"Getting started"},{"location":"registry/setup/#getting-started","text":"The supported way of setting up the Colony Registry is using docker-compose . Create the following docker-compose.yml file: version : '3.5' services : colony-registry : network_mode : host hostname : colony-registry container_name : colony-registry image : gobridget/colony-registry:latest restart : always Start up the Colony Registry with docker-compose up -d .","title":"Getting started"}]}